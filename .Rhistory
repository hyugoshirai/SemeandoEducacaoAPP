library(shiny)
# Run the application
# shinyApp(ui = ui.R, server = server.R)
runApp()
`Unidades de conservação`
names(`Unidades de conservação`)
# This script converts shapefiles to GeoJSON format using the sf package in R.
# Load necessary library
if (!require("sf")) install.packages("sf")
library(sf)
# Define the conversion function with an additional parameter for the file pattern
ConvertShapefileToGeojson <- function(shapefile_path, output_geojson_path, pattern = "\\pol_UCs.shp$") {
# Ensure the output directory exists
if (!dir.exists(output_geojson_path)) {
dir.create(output_geojson_path, recursive = TRUE)
}
# List all files in the shapefile_path matching the given pattern
files <- list.files(shapefile_path, pattern = pattern, full.names = TRUE)
# Loop through each file and convert to GeoJSON
for (file in files) {
# Extract the base name of the file (without extension)
base_name <- tools::file_path_sans_ext(basename(file))
# Define the output GeoJSON file path
output_geojson_file <- file.path(output_geojson_path, paste0(base_name, ".geojson"))
# Convert the shapefile to GeoJSON
sf::st_write(sf::st_read(file), output_geojson_file, driver = "GeoJSON")
# Print the conversion message
print(paste("Converted", file, "to", output_geojson_file))
}
}
# # Example of using a different pattern
# convert_files_to_geojson(shapefile_path, output_geojson_path, pattern = "\\.gdb$")
shapefile_path <- "H:/My Drive/SemeandoEducacaoAPP/Dados/Shapefiles"
output_geojson_path <- "H:/My Drive/SemeandoEducacaoAPP/Dados/GeoJSON"
# # Convert shapefiles using default pattern
ConvertShapefileToGeojson(shapefile_path, output_geojson_path)
# This script converts shapefiles to GeoJSON format using the sf package in R.
# Load necessary library
if (!require("sf")) install.packages("sf")
library(sf)
# This script converts shapefiles to GeoJSON format using the sf package in R.
# Load necessary library
if (!require("sf")) install.packages("sf")
library(sf)
# Define the conversion function with an additional parameter for the file pattern
ConvertShapefileToGeojson <- function(shapefile_path, output_geojson_path, pattern = "\\pol_UCs.shp$") {
# Ensure the output directory exists
if (!dir.exists(output_geojson_path)) {
dir.create(output_geojson_path, recursive = TRUE)
}
# List all files in the shapefile_path matching the given pattern
files <- list.files(shapefile_path, pattern = pattern, full.names = TRUE)
# Loop through each file and convert to GeoJSON
for (file in files) {
# Extract the base name of the file (without extension)
base_name <- tools::file_path_sans_ext(basename(file))
# Define the output GeoJSON file path
output_geojson_file <- file.path(output_geojson_path, paste0(base_name, ".geojson"))
# Convert the shapefile to GeoJSON
sf::st_write(sf::st_read(file), output_geojson_file, driver = "GeoJSON", delete_layer = TRUE)
# Print the conversion message
print(paste("Converted", file, "to", output_geojson_file))
}
}
# # Example of using a different pattern
# convert_files_to_geojson(shapefile_path, output_geojson_path, pattern = "\\.gdb$")
shapefile_path <- "H:/My Drive/SemeandoEducacaoAPP/Dados/Shapefiles"
output_geojson_path <- "H:/My Drive/SemeandoEducacaoAPP/Dados/GeoJSON"
# # Convert shapefiles using default pattern
ConvertShapefileToGeojson(shapefile_path, output_geojson_path)
# This script converts shapefiles to GeoJSON format using the sf package in R.
# Load necessary library
if (!require("sf")) install.packages("sf")
library(sf)
# Define the conversion function with an additional parameter for the file pattern
ConvertShapefileToGeojson <- function(shapefile_path, output_geojson_path, pattern = "\\pol_UCs.shp$") {
# Ensure the output directory exists
if (!dir.exists(output_geojson_path)) {
dir.create(output_geojson_path, recursive = TRUE)
}
# List all files in the shapefile_path matching the given pattern
files <- list.files(shapefile_path, pattern = pattern, full.names = TRUE)
# Loop through each file and convert to GeoJSON
for (file in files) {
# Extract the base name of the file (without extension)
base_name <- tools::file_path_sans_ext(basename(file))
# Define the output GeoJSON file path
output_geojson_file <- file.path(output_geojson_path, paste0(base_name, ".geojson"))
# Convert the shapefile to GeoJSON
sf::st_write(sf::st_read(file), output_geojson_file, driver = "GeoJSON", delete_dsn = TRUE)
# Print the conversion message
print(paste("Converted", file, "to", output_geojson_file))
}
}
# # Example of using a different pattern
# convert_files_to_geojson(shapefile_path, output_geojson_path, pattern = "\\.gdb$")
shapefile_path <- "H:/My Drive/SemeandoEducacaoAPP/Dados/Shapefiles"
output_geojson_path <- "H:/My Drive/SemeandoEducacaoAPP/Dados/GeoJSON"
# # Convert shapefiles using default pattern
ConvertShapefileToGeojson(shapefile_path, output_geojson_path)
# This script converts shapefiles to GeoJSON format using the sf package in R.
# Load necessary library
if (!require("sf")) install.packages("sf")
library(sf)
# Define the conversion function with an additional parameter for the file pattern
ConvertShapefileToGeojson <- function(shapefile_path, output_geojson_path, pattern = "\\pol_UCs.shp$") {
# Ensure the output directory exists
if (!dir.exists(output_geojson_path)) {
dir.create(output_geojson_path, recursive = TRUE)
}
# List all files in the shapefile_path matching the given pattern
files <- list.files(shapefile_path, pattern = pattern, full.names = TRUE)
# Loop through each file and convert to GeoJSON
for (file in files) {
# Extract the base name of the file (without extension)
base_name <- tools::file_path_sans_ext(basename(file))
# Define the output GeoJSON file path
output_geojson_file <- file.path(output_geojson_path, paste0(base_name, ".geojson"))
# Convert the shapefile to GeoJSON
sf::st_write(sf::st_read(file), output_geojson_file, driver = "GeoJSON")
# Print the conversion message
print(paste("Converted", file, "to", output_geojson_file))
}
}
# # Example of using a different pattern
# convert_files_to_geojson(shapefile_path, output_geojson_path, pattern = "\\.gdb$")
shapefile_path <- "H:/My Drive/SemeandoEducacaoAPP/Dados/Shapefiles"
output_geojson_path <- "H:/My Drive/SemeandoEducacaoAPP/Dados/GeoJSON"
# # Convert shapefiles using default pattern
ConvertShapefileToGeojson(shapefile_path, output_geojson_path)
# Note: not necessary to load packages here: this all happens in global.R
# Increase the file upload size limit to 30MB
options(shiny.maxRequestSize = 30 * 1024^2)
library(shiny)
# Run the application
# shinyApp(ui = ui.R, server = server.R)
runApp()
# Note: not necessary to load packages here: this all happens in global.R
# Increase the file upload size limit to 30MB
options(shiny.maxRequestSize = 30 * 1024^2)
library(shiny)
# Run the application
# shinyApp(ui = ui.R, server = server.R)
runApp()
View(`Uso do solo`)
# Note: not necessary to load packages here: this all happens in global.R
# Increase the file upload size limit to 30MB
options(shiny.maxRequestSize = 30 * 1024^2)
library(shiny)
# Run the application
# shinyApp(ui = ui.R, server = server.R)
runApp()
View(`Uso do solo`)
`Uso do solo`
# Note: not necessary to load packages here: this all happens in global.R
# Increase the file upload size limit to 30MB
options(shiny.maxRequestSize = 30 * 1024^2)
library(shiny)
# Run the application
# shinyApp(ui = ui.R, server = server.R)
runApp()
default_shapefiles
names (default_shapefiles)
# Note: not necessary to load packages here: this all happens in global.R
# Increase the file upload size limit to 30MB
options(shiny.maxRequestSize = 30 * 1024^2)
library(shiny)
# Run the application
# shinyApp(ui = ui.R, server = server.R)
runApp()
# Note: not necessary to load packages here: this all happens in global.R
# Increase the file upload size limit to 30MB
options(shiny.maxRequestSize = 30 * 1024^2)
library(shiny)
# Run the application
# shinyApp(ui = ui.R, server = server.R)
runApp()
# Note: not necessary to load packages here: this all happens in global.R
# Increase the file upload size limit to 30MB
options(shiny.maxRequestSize = 30 * 1024^2)
library(shiny)
# Run the application
# shinyApp(ui = ui.R, server = server.R)
runApp()
default_layers
names (default_layers)
names (default_shapefiles)
# Note: not necessary to load packages here: this all happens in global.R
# Increase the file upload size limit to 30MB
options(shiny.maxRequestSize = 30 * 1024^2)
library(shiny)
# Run the application
# shinyApp(ui = ui.R, server = server.R)
runApp()
setShapeStyle
# Note: not necessary to load packages here: this all happens in global.R
# Increase the file upload size limit to 30MB
options(shiny.maxRequestSize = 30 * 1024^2)
library(shiny)
# Run the application
# shinyApp(ui = ui.R, server = server.R)
runApp()
# Note: not necessary to load packages here: this all happens in global.R
# Increase the file upload size limit to 30MB
options(shiny.maxRequestSize = 30 * 1024^2)
library(shiny)
# Run the application
# shinyApp(ui = ui.R, server = server.R)
runApp()
# Note: not necessary to load packages here: this all happens in global.R
# Increase the file upload size limit to 30MB
options(shiny.maxRequestSize = 30 * 1024^2)
library(shiny)
# Run the application
# shinyApp(ui = ui.R, server = server.R)
runApp()
# Note: not necessary to load packages here: this all happens in global.R
# Increase the file upload size limit to 30MB
options(shiny.maxRequestSize = 30 * 1024^2)
library(shiny)
# Run the application
# shinyApp(ui = ui.R, server = server.R)
runApp()
# Note: not necessary to load packages here: this all happens in global.R
# Increase the file upload size limit to 30MB
options(shiny.maxRequestSize = 30 * 1024^2)
library(shiny)
# Run the application
# shinyApp(ui = ui.R, server = server.R)
runApp()
# Note: not necessary to load packages here: this all happens in global.R
# Increase the file upload size limit to 30MB
options(shiny.maxRequestSize = 30 * 1024^2)
library(shiny)
# Run the application
# shinyApp(ui = ui.R, server = server.R)
runApp()
# Note: not necessary to load packages here: this all happens in global.R
# Increase the file upload size limit to 30MB
options(shiny.maxRequestSize = 30 * 1024^2)
library(shiny)
# Run the application
# shinyApp(ui = ui.R, server = server.R)
runApp()
# This function defines the labels and colors for different mapping features.
# Mapping from labels to colors
LabeltoColor <- function(label) {
switch(label,
"Áreas verdes" = "green",
"Corpos d'água" = "blue",
"Áreas urbanas" = "gray",
"Escola" = "purple",
"Indústria" = "orange",
"Agricultura" = "yellow",
"Pastagem" = "brown",
"Silvicultura" = "darkgreen",
"black")  # Default color if label does not match
}
# Note: not necessary to load packages here: this all happens in global.R
# Increase the file upload size limit to 30MB
options(shiny.maxRequestSize = 30 * 1024^2)
library(shiny)
# Run the application
# shinyApp(ui = ui.R, server = server.R)
runApp()
Q
# Note: not necessary to load packages here: this all happens in global.R
# Increase the file upload size limit to 30MB
options(shiny.maxRequestSize = 30 * 1024^2)
library(shiny)
# Run the application
# shinyApp(ui = ui.R, server = server.R)
runApp()
initializeMap <- function(ProjectArea, Phito, StateLimits, ProtectedAreas, LandUse_rst) {
# Aggregate the raster for faster visualization
factor <- 5
Uso_do_Solo_agg <- raster::aggregate(LandUse_rst, fact = factor, fun = modal)
# Create the leaflet map
leaflet() %>%
addTiles(group = "OpenStreetMap") %>%
addTiles(urlTemplate = "https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}", group = "Satellite") %>%
# Add ProjectArea layer
addPolygons(data = ProjectArea,
color = "red",
weight = 1.5,
opacity = 1,
fillOpacity = 0,
group = "Sistema Cantareira"
) %>%
# Add StateLimits layer
addPolygons(data = StateLimits,
color = "grey",
weight = 1,
opacity = 1,
group = "Limites estaduais",
fillOpacity = 0.5,
popup = ~paste("Nome da UF: ", NM_UF)
) %>%
# Add Phito layer
addPolygons(data = Phito,
color = ~Phito_pal(Phito_labels),
weight = 1,
opacity = 1,
fillOpacity = 0.5,
group = "Fitofisionomias",
popup = ~legenda
) %>%
# Properties legend
addLegend(
position = "bottomleft",
colors = Phito_colors,
labels = Phito_labels,
title = "Fitofisionomias",
group = "Fitofisionomias"
) %>%
# Add Land Use raster layer
addRasterImage(Uso_do_Solo_agg,
colors = land_use_pal,
group = "Uso do solo",
project = TRUE,
method = 'ngb'
) %>%
# Land use legend
addLegend(
position = "bottomleft",
pal = land_use_pal,
values = sort(unique(values(LandUse_rst))),
title = "Uso do solo",
labFormat = labelFormat(transform = function(x) landuse_df$land_use[match(x, landuse_df$raster_value)]),
opacity = 1,
group = "Uso do solo"
) %>%
# Add Protected Areas layer
addPolygons(
data = ProtectedAreas,
color = ~spa_pal(Tipo),
weight = 1,
opacity = 1,
fillOpacity = 0.5,
group = "Unidades de conservação",
popup = ~paste("Nome da UC: ", NOME_UC1, "Categoria: ", CATEGORI3, "Codigo: ", CODIGO_U11)
) %>%
# Add a legend for the protected areas
addLegend(
pal = spa_pal,
values = spa_labels,
title = "Unidades de conservação",
position = "bottomleft",
group = "Unidades de conservação"
) %>%
# Add drawing tools
addDrawToolbar(
polylineOptions = TRUE,
polygonOptions = drawPolygonOptions(),
circleOptions = FALSE,
rectangleOptions = drawRectangleOptions(),
markerOptions = drawMarkerOptions(),
circleMarkerOptions = FALSE,
singleFeature = FALSE,
editOptions = editToolbarOptions()
) %>%
# Add scale bar
addScaleBar(
position = "bottomright",
options = scaleBarOptions(imperial = FALSE, metric = TRUE)
) %>%
# Add OSM search
addSearchOSM(
options = searchOptions(autoCollapse = TRUE, minLength = 2)
) %>%
# Add measurement tools
addMeasure(
position = "topright",
primaryLengthUnit = "meters",
primaryAreaUnit = "sqmeters"
) %>%
# Add layer control
addLayersControl(
baseGroups = c("OpenStreetMap", "Satellite"),
overlayGroups = c("Sistema Cantareira", "Limites estaduais", "Fitofisionomias", "Uso do solo", "Unidades de conservação"),
options = layersControlOptions(collapsed = TRUE)
) %>%
# Hide groups by default
hideGroup(c("Limites estaduais", "Unidades de conservação", "Uso do solo", "Fitofisionomias")) %>%
# Fit the bounds of the map to the project area
fitBounds(lng1 = min(st_bbox(ProjectArea)[c("xmin")]),
lat1 = min(st_bbox(ProjectArea)[c("ymin")]),
lng2 = max(st_bbox(ProjectArea)[c("xmax")]),
lat2 = max(st_bbox(ProjectArea)[c("ymax")]))
}
initializeMap(ProjectArea = `Sistema Cantareira`,
Phito = Fitofisionomias,
StateLimits = `Limites estaduais`,
ProtectedAreas = `Unidades de conservação`,
LandUse_rst = `Uso do solo`)
# # Check if 'remotes' package is installed
# if (!requireNamespace("remotes", quietly = TRUE)) {
#   install.packages("remotes")
# }
#
# # Function to check if a package is installed, if not, install it
# install_if_needed <- function(package, github_repo = NULL) {
#   if (!requireNamespace(package, quietly = TRUE)) {
#     if (!is.null(github_repo)) {
#       message(paste(package, "is not installed. Installing from GitHub repository:", github_repo))
#       remotes::install_github(github_repo)
#     } else {
#       message(paste(package, "is not installed. Installing from CRAN."))
#       install.packages(package)
#     }
#   } else {
#     message(paste(package, "is already installed."))
#   }
# }
#
# # Check and install the 'icons' package from GitHub if not already installed
remotes::install_github("mitchelloharawild/icons")
# install_if_needed("icons", github_repo = "mitchelloharawild/icons")
#
# # Packages list
# packages <- c("shiny", "leaflet", "raster", "DT", "shinyWidgets",
#               "sf", "leafem", "mapview", "gdistance", "dplyr",
#               "shinyFiles", "zip", "leaflet.extras",
#               "shinyjs", "classInt", "leastcostpath", "terra", "units", "tools",
#               "shinyalert", "icons", "fontawesome", "RColorBrewer")
# # library(icons)
# # download_fontawesome() #only if needed
#
# # Instalar pacotes que não estão instalados
# new_packages <- packages[!(packages %in% installed.packages()[, "Package"])]
# if (length(new_packages)) {
#   install.packages(new_packages)
# }
# Load required packages ----
library("classInt")
library("dplyr")
library ("DT")
# library("fontawesome")
library("gdistance")
# library("icons")
library("leafem")
library("leaflet")
library("leaflet.extras")
library("leastcostpath")
library("mapview")
library("raster")
library("RColorBrewer")
library("shiny")
library("shinyFiles")
library("shinyWidgets")
library("shinyalert")
library("shinyjs")
library("sf")
library("terra")
library("tools")
library("units")
library("zip")
# terraOptions(memfrac = 0.9, progress  = 1) # Set terra options
#### Source Modules
# Define the directory containing the R script files
modules_directory <- "modules"
# List all .R files in the directory
script_files <- list.files(modules_directory, pattern = "\\.R$", full.names = TRUE)
# Loop through each R file and source it
for (script_file in script_files) {
source(script_file)
print (paste("Sourced", script_file))
}
### Initialize objects ----
# Create objects from sheet
AssignObjectsFromGsheet("https://docs.google.com/spreadsheets/d/1eRSEmnMIIEcS6EUkhOguy_mCRpZRN1vy/edit?usp=sharing&ouid=102538809962333046552&rtpof=true&sd=true")
# Initialize the lists to store the default objects
default_shapefiles <- list() # List for vectors
default_layers <- list() # List for rasters
# Add the objects to the reactive lists based on their type
CategorizeAndReprojectObjectsInGlobalEnv()
# Define custom control names
custom_control <- setdiff (c(names (default_layers), names (default_shapefiles)),
c("Estações de tratamento", "Pontos de captação"))
### 5. Define reactive values  ----
all_points <- reactiveVal(list()) # For storing all points
all_reclassified_rasters <- reactiveVal(list()) # Create a reactive list to hold all reclassified rasters
all_shapefiles <- reactiveVal(list()) # For storing the shapefiles
checkbox_layers <- reactiveVal(c("Original Raster")) # Initialize a reactive value to store the checkbox layers
current_layers <- reactiveVal(character(0)) # Create a reactive list to hold current layers name
default_layers_name <- reactiveVal() # Create a reactive value to store the default layers name
default_layers_reclass_df <- reactiveVal() # Create a reactive value to store the default layers reclassification dataframe
features_list <- reactiveVal(list())  # Create a reactive value to store the features list
dinamic_added <- reactiveVal(list()) # For storing dynamic added layers
downldropdown <- reactiveValues(dropdowns = "layers_dropdown") # Reactive value to store the dropdown identifier
euclidean_dist_rasters <- reactiveValues() # Create a reactive value to store the euclidean distance rasters
euclidean_reclass_df <- reactiveVal() # Reactive value to store the reclassification dataframe for euclidean distance
feature_values_data <- reactiveVal(NULL) # For storing feature values data
layer_colors <- reactiveValues(list = list()) # Redirect layer colors to observe later listItem
rasterized_layer <- reactiveVal(NULL) # For storing rasterized shapefile
reactive_tabs <- reactiveVal(list()) # For storing tab names
raster_data_processed <- reactiveVal(NULL) # For storing the processed raster data
# Rec_LandUse <- reactiveVal(LandUse_rst) # For storing reclassified LandUse data
raster_df <- reactiveVal() # For storing raster data frames
raster_df_list <- reactiveVal(list()) # For storing raster data frames list
rendered_table <- renderDT({
features_table_data()
}, editable = list(target = "cell", disable = list(columns = c(0, 1, 3, 4))), selection = 'multiple', server = FALSE)
# Render the features table
result_raster <- reactiveVal(NULL) # For storing result raster
shapefile_data <- reactiveValues(shp = NULL, colors = list()) # For storing the uploaded shapefile data
shapefile_data_processed <- reactiveVal(NULL) # For storing the processed shapefile data
shapefile_names_list <- reactiveVal(character(0)) # For storing the names of uploaded shapefiles
shortest_path_counter <- reactiveVal(0) # Counter for shortest path
shortest_path_layers <- reactiveValues(list = list()) # Create a reactive value to store the shortest path layers
shortest_path_result <- reactiveVal(NULL) # For storing shortest path result
selected_layer <- reactiveVal(NULL) # For storing the selected layer in the dropdown list
